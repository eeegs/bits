//-----------------------------------------------------------------------------
//
//    ** DO NOT EDIT THIS FILE! **
//    This file was generated by a tool
//    re-running the tool will overwrite this file.
//
//-----------------------------------------------------------------------------

#include "CA_Library.h"

bool lowCallback(adc_monitor_handle_t monitor_handle, const adc_monitor_evt_data_t *event_data, void *user_data)
{
    ESP_LOGI("TAG", "Monitor low event triggered");
    PostManagedEvent(EVENT_CUSTOM, 1, 0, 0);
    return true;
}

bool highCallback(adc_monitor_handle_t monitor_handle, const adc_monitor_evt_data_t *event_data, void *user_data)
{
    ESP_LOGI("TAG", "Monitor high event triggered");
    PostManagedEvent(EVENT_CUSTOM, 2, 0, 0);
    return true;
}

HRESULT CA_Library_ACDMonitor::SetupMonitor(CLR_RT_StackFrame &stack)
{
    NANOCLR_HEADER();

    handle = NULL;
    monitor_handle = NULL;

    hr = S_OK;
    {
        signed int unit;
        NANOCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 0, unit));

        signed int pin;
        NANOCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 1, pin));

        double lowThreshold;
        NANOCLR_CHECK_HRESULT(Interop_Marshal_double(stack, 2, lowThreshold));

        double highThreshold;
        NANOCLR_CHECK_HRESULT(Interop_Marshal_double(stack, 3, highThreshold));

        adc_monitor_config_t monitor_config;
        monitor_config.adc_unit = (adc_unit_t)unit;
        monitor_config.channel = (adc_channel_t)pin;
        monitor_config.h_threshold =
            lowThreshold; /*!<Set monitor high threshold of adc digital controller, -1 if not used. */
        monitor_config.l_threshold = highThreshold;

        adc_continuous_handle_cfg_t adc_config;
        adc_config.max_store_buf_size = 1024;
        adc_config.conv_frame_size = 256;

        adc_monitor_evt_cbs_t cbs_monitor = {
            .on_over_high_thresh = highCallback,
            .on_below_low_thresh = lowCallback,
        };

        esp_err_t ret;

        ret = adc_continuous_new_handle(&adc_config, &handle);
        if (ret != ESP_OK)
        {
            ESP_LOGE("TAG", "Failed to create new continuous handle: %s", esp_err_to_name(ret));
        }

        ret = adc_new_continuous_monitor(handle, &monitor_config, &monitor_handle);
        if (ret != ESP_OK)
        {
            ESP_LOGE("TAG", "Failed to create new monitor: %s", esp_err_to_name(ret));
        }

        ret = adc_continuous_monitor_register_event_callbacks(monitor_handle, &cbs_monitor, NULL);
        if (ret != ESP_OK)
        {
            ESP_LOGE("TAG", "Failed to register monitor event callbacks: %s", esp_err_to_name(ret));
        }

        ret = adc_continuous_monitor_enable((adc_monitor_handle_t)monitor_handle);
        if (ret != ESP_OK)
        {
            ESP_LOGE("TAG", "Failed to enable ADC monitor: %s", esp_err_to_name(ret));
        }

        NANOCLR_CHECK_HRESULT(hr);
    }
    NANOCLR_NOCLEANUP();
}

HRESULT CA_Library_ACDMonitor::DisposeMonitor(CLR_RT_StackFrame &stack)
{
    NANOCLR_HEADER();
    hr = S_OK;
    {
        adc_continuous_monitor_disable(monitor_handle);
        adc_del_continuous_monitor(monitor_handle);
        adc_continuous_deinit(handle);
        NANOCLR_CHECK_HRESULT(hr);
    }
    NANOCLR_NOCLEANUP();
}
